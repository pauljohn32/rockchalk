#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrartcl
\begin_preamble
%\VignetteIndexEntry{Using rockchalk}

\usepackage{Sweavel}
\usepackage{graphicx}
\usepackage{color}

\usepackage[samesize]{cancel}



\usepackage{ifthen}

\makeatletter

\renewenvironment{figure}[1][]{%
 \ifthenelse{\equal{#1}{}}{%
   \@float{figure}
 }{%
   \@float{figure}[#1]%
 }%
 \centering
}{%
 \end@float
}

\renewenvironment{table}[1][]{%
 \ifthenelse{\equal{#1}{}}{%
   \@float{table}
 }{%
   \@float{table}[#1]%
 }%
 \centering
%  \setlength{\@tempdima}{\abovecaptionskip}%
%  \setlength{\abovecaptionskip}{\belowcaptionskip}%
% \setlength{\belowcaptionskip}{\@tempdima}%
}{%
 \end@float
}


%\usepackage{listings}
% Make ordinary listings look as if they come from Sweave
\lstset{tabsize=2, breaklines=true, %,style=Rstyle}
                        fancyvrb=false,escapechar=`,language=R,%
                        %%basicstyle={\Rcolor\Sweavesize},%
                        backgroundcolor=\Rbackground,%
                        showstringspaces=false,%
                        keywordstyle=\Rcolor,%
                        commentstyle={\Rcommentcolor\ttfamily\itshape},%
                        literate={<<-}{{$\twoheadleftarrow$}}2{~}{{$\sim$}}1{<=}{{$\leq$}}2{>=}{{$\geq$}}2{^}{{$^{\scriptstyle\wedge}$}}1{==}{{=\,=}}1,%
                        alsoother={$},%
                        alsoletter={.<-},%
                        otherkeywords={!,!=,~,$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-,/},%
                        escapeinside={(*}{*)}}%


% In document Latex options:
\fvset{listparameters={\setlength{\topsep}{0em}}}
\def\Sweavesize{\scriptsize} 
\def\Rcolor{\color{black}} 
\def\Rbackground{\color[gray]{0.90}}

\usepackage{dcolumn}
\usepackage{siunitx}
\end_preamble
\use_default_options true
\begin_modules
sweave
logicalmkup
\end_modules
\maintain_unincluded_children false
\language american
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Using rockchalk for Regression Analysis
\begin_inset Foot
status open

\begin_layout Plain Layout
In case you want to be involved in development, the source code is available
 on GitHub.
 Please browse http://github.com/pauljohn32.
 The read-only git archive address is 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

git://github.com/pauljohn32/rockchalk.git
\end_layout

\end_inset

.
 Once you learn how to 
\begin_inset Quotes eld
\end_inset

clone
\begin_inset Quotes erd
\end_inset

 the repository with a git client, then we can discuss ways for you to contribut
e.
\end_layout

\end_inset


\end_layout

\begin_layout Author
Paul E.
 Johnson
\end_layout

\begin_layout Abstract
The rockchalk package includes functions for estimating regressions, extracting
 diagnostic information from them, preparing presentable tables, and creating
 helpful two and three dimensional plots.
 It is primarily intended to facilitate teachers and students who are conducting
 ordinary least squares and elementary generalized models.
 Compared to other packages that help with regression analysis, this one
 offers more-than-the-usual amount of emphasis on the analysis of regression
 models that include interaction terms.
 It includes functions that can receive a fitted model and then return standardi
zed, mean-centered, and residual-centered regression results.
 The plotting functions address some limitations of R's 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
termplot
\end_layout

\end_inset

 function.
 Version 1.8 introduces a consistent framework for the creation of 
\begin_inset Quotes eld
\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout
newdata
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 objects and the calculation of predicted values so that the marginal effects
 of separate predictors can be easily explored.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% In document Latex options:
\end_layout

\begin_layout Plain Layout


\backslash
fvset{listparameters={
\backslash
setlength{
\backslash
topsep}{0em}}}
\end_layout

\begin_layout Plain Layout


\backslash
SweaveOpts{ae=F,nogin=T}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Roptions, echo=F>>=
\end_layout

\begin_layout Plain Layout

options(device = pdf)
\end_layout

\begin_layout Plain Layout

options(width=80, prompt=" ", continue="  ")
\end_layout

\begin_layout Plain Layout

options(useFancyQuotes = FALSE) 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
This is the Fall, 2018 update of the rockchalk package.
 I offer a course in regression analysis for social and behavioral scientists
 every year.
 As the course goes on, I keep track of the difficulties that the students
 experience with R and I craft functions that facilitate their work on particula
r assignments.
 The new features in this edition are the functions 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
descriptiveTables()
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
waldt()
\end_layout

\end_inset

 (for regression reports), tools for regression simulation, including 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
genCorrelatedData3()
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
cutFancy()
\end_layout

\end_inset

, some support for common recoding support for multi-level modeling.
 Finally, the regression table-writing function the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
outreg()
\end_layout

\end_inset

 can now generate decimal-aligned columns.
 A new vignette demonstrating the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
outreg()
\end_layout

\end_inset

 function is introduced with the package.
\end_layout

\begin_layout Standard
As in previous versions, a core of the effort is development of an internally
 coherent framework that allows students to estimate regressions (usually
 with lm and glm) and then create useful summary tables and diagnostic reports.
 It is easy to create 
\begin_inset Quotes eld
\end_inset

newdata
\begin_inset Quotes erd
\end_inset

 objects and interact with fitted regressions.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
newdata()
\end_layout

\end_inset

 function will be handy for just about any kind of regression.
 For the common kinds of regression in base R and lme4, there is also a
 convenience function called 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
predictOMatic()
\end_layout

\end_inset

 that allows one to specify a regression model and then receive predicted
 values for a range of input values.
 The default output will be similar to other regression software tools that
 provide 
\begin_inset Quotes eld
\end_inset

marginal effect
\begin_inset Quotes erd
\end_inset

 estimates for regression analysis.
 
\end_layout

\begin_layout Standard
I have exerted a great deal of effort to improve the consistency of predicted
 value plots for regression analysis.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
plotSlopes()
\end_layout

\end_inset

 function is a plotter for linear models with interaction terms.
 It draws a plot on the screen, but it also creates an output object that
 can be subjected to a follow-up hypothesis test (by the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
testSlopes()
\end_layout

\end_inset

 function).
 There is a plot method for testSlopes objects to help with analysis of
 interactions.
 
\end_layout

\begin_layout Standard
For people who want to plot nonlinear regressions, the function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
plotCurves()
\end_layout

\end_inset

 is a replacement for 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
plotSlopes()
\end_layout

\end_inset

.
 It can handle any sort of nonlinearity and interaction on the right hand
 side.
 Where some regression formula can cause R's 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
termplot()
\end_layout

\end_inset

 function to fail, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
plotCurves()
\end_layout

\end_inset

 will succeed.
\end_layout

\begin_layout Standard
The core functionality of many functions has not been altered.
 Functions to provide standardized regression coefficients, mean-centered,
 or residual-centered regression coefficients have not changed much, although
 the plots of them are improved.
 
\end_layout

\begin_layout Section
Facilitating Collection of Summary Information
\end_layout

\begin_layout Subsection
summarize: A replacement for summary
\end_layout

\begin_layout Standard
When an R function provides output that is not suitable for a term paper,
 the student must cobble together some code and assemble a customized table.
 In my opinion, R's summary() function for data frames is not adequate.
 It lacks summaries for diversity of observations.
 In addition, the output is not formatted in a way that is conducive to
 the creation of plots or tables.
 As a result, I offer the function summarize(), which separates the numeric
 from factor variables and provides an alphabetized summary.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=F>>=
\end_layout

\begin_layout Plain Layout

library(rockchalk)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consider the results of applying summarize() to Fox's Chile data set from
 the car package:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=T>>=
\end_layout

\begin_layout Plain Layout

library(car)
\end_layout

\begin_layout Plain Layout

data(Chile)
\end_layout

\begin_layout Plain Layout

(summChile <- summarize(Chile))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The result object is a list that includes a data frame for the numeric variables
, with named rows and (optionally) alphabetized columns, as well as a separate
 report for each factor variable.
 Users who wish to summarize only the numeric variables can run summarizeNumeric
s() instead, while others who want to summarize only factors can run summarizeFa
ctors().
 The output from summarizeFactors() is a list of factor summaries.
 
\end_layout

\begin_layout Standard
A companion function is centralValues(), which will provide only one number
 for each variable in a data frame.
 For numerics, it returns the mean, while for factor variables, it returns
 the mode.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=T>>=
\end_layout

\begin_layout Plain Layout

centralValues(Chile)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Easier predictions and newdata objects
\end_layout

\begin_layout Standard
Students struggle with R's predict() methods.
 The primary challenge is in the creation of a newdata object of interesting
 values of the predictors.
 If the newdata argument, here myNewDF in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

predict(m1, newdata = myNewDF)
\end_layout

\end_inset

 is not exactly right, the command will fail.
 If the regression formula uses functions like 
\begin_inset Quotes eld
\end_inset

as.numeric()
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

as.factor()
\begin_inset Quotes erd
\end_inset

, its almost impossible for first-time R users to get this right.
 In version 1.8, I believe I have solved the problem entirely with the functions
 newdata() and predictOMatic().
 
\end_layout

\begin_layout Standard
Let's fit an example regression with the Chile data set from the car package.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=T>>=
\end_layout

\begin_layout Plain Layout

m1 <- lm(statusquo ~ age + income + population + region + sex, data = Chile)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The default output of predictOMatic() will cycle through the predictors,
 one by one.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=T>>=
\end_layout

\begin_layout Plain Layout

m1pred <- predictOMatic(m1)
\end_layout

\begin_layout Plain Layout

m1pred
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The newdata() and predictOMatic() functions handle the details and allow
 the user to adjust their requests to allow for very fine grained control.
 Here are the key arguments for these functions.
\end_layout

\begin_layout Enumerate
divider.
 The name of an algorithm to select among observed values for which predictions
 are to be calculated.
 These are the possibilities.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Description
\begin_inset Quotes eld
\end_inset

seq
\begin_inset Quotes erd
\end_inset

 an evenly spaced sequence of values from low to high across the variable.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

quantile
\begin_inset Quotes erd
\end_inset

 quantile values that eminate from the center of the variable 
\begin_inset Quotes eld
\end_inset

outward
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

std.dev.
\begin_inset Quotes erd
\end_inset

 the mean plus or minus the standard deviation, or 2 standard deviations,
 and so forth.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

table
\begin_inset Quotes erd
\end_inset

 when a variable has only a small set of possible values, this selects the
 most frequently observed values.
\end_layout

\end_deeper
\begin_layout Enumerate
n.
 The number of values to be selected.
\end_layout

\begin_layout Enumerate
predVals.
 Where the divider argument sets the default algorithm to be used, the predVals
 argument can choose variables for focus and select divider algorithms separatel
y for the variables.
 It is also allowed to declare particular values.
\end_layout

\begin_layout Standard
The user can request that particular values of the predictors are used,
 or can declare one of several algorithms for selection of focal values.
 All of these details are managed by the argument called predVals, which
 is described in the help pages (with plenty of examples).
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=T>>=
\end_layout

\begin_layout Plain Layout

mypred2 <- predictOMatic(m1, predVals = c("age", "region"), n = 3)
\end_layout

\begin_layout Plain Layout

mypred2
\end_layout

\begin_layout Plain Layout

mypred3 <- predictOMatic(m1, predVals = c(age = "std.dev.", region = "table"),
 n = 3)
\end_layout

\begin_layout Plain Layout

mypred3
\end_layout

\begin_layout Plain Layout

mypred4 <- predictOMatic(m1, predVals = list(age = c(18, 30, 45), region
 = c("SA", "C","N")), n = 3)
\end_layout

\begin_layout Plain Layout

mypred4
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I've invested quite a bit of effort to make sure this works dependably with
 complicated regression formulae.
 All formulae, such as y ~ x1 + log(x2 + alpha) + ploy(x3, d) will just
 work.
 (In case one is interested to know 
\emph on
why
\emph default
 this works, the secret recipe is a new function called model.data().
 Under the hood, this required some hard work, a frustrating chain of trial
 and error that is discussed in the vignette 
\emph on
Rchaeology
\emph default
, which is distributed with this package).
\end_layout

\begin_layout Standard
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
predictOMatic()
\end_layout

\end_inset

 function will work when the regression model provides a predict function
 that can handle the newdata argument.
 If the regression package does not provide such a function, the user should
 step back and use the newdata function to create the examplar predictor
 data frames and then calculate predicted values manually.
 The newdata() function will set all variables to center values and then
 it will create a 
\begin_inset Quotes eld
\end_inset

mix and match
\begin_inset Quotes erd
\end_inset

 combination of the ones that the user asks for.
 This sequence shows ways to ask for various 
\begin_inset Quotes eld
\end_inset

mix and match
\begin_inset Quotes erd
\end_inset

 combinations of values from age and region.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=T>>=
\end_layout

\begin_layout Plain Layout

mynewdf <- newdata(m1, predVals = c("age","region"), n = 3)
\end_layout

\begin_layout Plain Layout

mynewdf
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=T>>=
\end_layout

\begin_layout Plain Layout

mynewdf2 <- newdata(m1, predVals = list(age = "std.dev.", region = c("SA",
 "C","N")))
\end_layout

\begin_layout Plain Layout

mynewdf2
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=T>>=
\end_layout

\begin_layout Plain Layout

mynewdf3 <- newdata(m1, predVals = list(age = c(20, 30, 40), region = c("SA",
 "C","N")))
\end_layout

\begin_layout Plain Layout

mynewdf3
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Of course, functions from rockchalk or any other R package can be placed
 into the process for choosing focal values.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=T>>=
\end_layout

\begin_layout Plain Layout

mynewdf <- newdata(m1, predVals = list(age = getFocal(Chile$age, n = 3),
 region = getFocal(Chile$region, n = 3)))
\end_layout

\begin_layout Plain Layout

mynewdf
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

The function getFocal() is a generic function; it will receive variables
 of different types and 
\begin_inset Quotes eld
\end_inset

do the right thing.
\begin_inset Quotes erd
\end_inset

 By default, focal values of numeric variables are quantile values.
 For factor values, the most frequently observed values are selected.
 These are customizable, as explained in the documentation.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
newdata()
\end_layout

\end_inset

 output can be used in a predict() function call as demonstrated above.
 
\end_layout

\begin_layout Standard
It would be nice if every regression model's predicted values were accompanied
 by 95% confidence intervals.
 Models fit by 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
lm()
\end_layout

\end_inset

 can supply confidence intervals, but not 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
glm()
\end_layout

\end_inset

.
 At the current time, there are many competing methods that might be used
 to calculate those intervals; predict.glm() in R's stats package avoids
 the issue entirely by not calculating intervals.
 In rockchalk-1.8, I crafted some code to calculate confidence intervals
 for glm objects using the (admittedly crude) Wald-based approximation.
 In the scale of the linear predictor, we calculate a 95% confidence interval,
 and then use the inverse link function to transform that onto the space
 of the observed response.
 In this example, I replicate an example that is an R classic, from the
 help page of predict.glm.
 The reader will note that the output includes a warning about the construction
 of the confidence interval.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=T>>=
\end_layout

\begin_layout Plain Layout

df <- data.frame(ldose = rep(0:5, 2), sex = factor(rep(c("M", "F"), c(6,
 6))), 
\end_layout

\begin_layout Plain Layout

	SF.numdead = c(1, 4, 9, 13, 18, 20, 0, 2, 6, 10, 12, 16))      
\end_layout

\begin_layout Plain Layout

df$SF.numalive <-  20 - df$SF.numdead
\end_layout

\begin_layout Plain Layout

budworm.lg <- glm(cbind(SF.numdead, SF.numalive) ~ sex*ldose, data = df,  family
 = binomial)
\end_layout

\begin_layout Plain Layout

predictOMatic(budworm.lg, predVals = c(ldose = "std.dev.", sex = "table"),
 interval = "confidence")  
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Descriptive Tables
\end_layout

\begin_layout Standard
In regression-based reports, it is common for authors to present a brief
 summary table to represent the data.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
descriptiveTable()
\end_layout

\end_inset

 function was created to make that process easier and more predictable.
 The aim is to provide the usual summary statistics for the numeric predictors
 and a table of proportions for the categorical predictors.
 See Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:descriptiveTable"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The user can customize the requested statistical summaries for numeric
 predictors.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The descriptiveTable function
\begin_inset CommandInset label
LatexCommand label
name "tab:descriptiveTable"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

descriptiveTable(m1, digits=6)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
I my opinion, the output is, well, simple and understandable.
 More importantly, it will be sufficient for a term paper, once it is converted
 into a presentable final format.
 It can be converted into HTML or LaTeX with various R packages, such as
 xtable.
 Note that because this descriptive table is derived from the fitted regression,
 it summarizes 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\noindent
only the cases
\end_layout

\end_inset

 that were actually used in the regression analysis.
 If cases were lost by listwise deletion, the deleted cases are not taken
 into account here.
\end_layout

\begin_layout Section
Better Regression Tables: Some outreg Examples.
\end_layout

\begin_layout Standard
On May 8, 2006, Dave Armstrong, who was a political science PhD student
 at University of Maryland, posted a code snippet in r-help that demonstrated
 one way to use the 
\begin_inset Quotes eld
\end_inset

cat
\begin_inset Quotes erd
\end_inset

 function from R to write \SpecialChar LaTeX
 markup.
 That gave me the idea to write a \SpecialChar LaTeX
 output scheme that would help create
 some nice looking term and research papers.
 I wanted 
\begin_inset Quotes eld
\end_inset

just enough
\begin_inset Quotes erd
\end_inset

 information, but not too much.
\end_layout

\begin_layout Standard
Since 2006, many new R packages have been introduced for the creation of
 regression tables, but I still prefer to maintain 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
outreg
\end_layout

\end_inset

.
 I fight to keep this simple, but have added some features in response to
 user requests.
 For me, the biggest question is whether the format should be 
\begin_inset Quotes eld
\end_inset

wide
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

tight
\begin_inset Quotes erd
\end_inset

.
 A tight format stacks estimates and standard errors into a single column,
 while a wide format has them in separate columns.
 In response to user requests, stars for statistical significance were made
 customizable.
 It is now allowed to directly insert vectors of parameter estimates and
 standard errors.
 In this version, a new parameter 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
centering
\end_layout

\end_inset

 is introduced for decimal-centered columns.
 
\end_layout

\begin_layout Standard
In the following, I will demonstrate some tables for lm and glm fits on
 a simulated data set.
 This new simulation function, genCorrelatedData2(), is a convenient way
 to create multiple-predictor regression data sets of arbitary size and
 complexity, allowing for interactions and nonlinearity.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<createdata1, echo=T>>=
\end_layout

\begin_layout Plain Layout

set.seed(1234)
\end_layout

\begin_layout Plain Layout

dat <- genCorrelatedData3(N = 100, means = c(x1 = 0, x2 = 10, x3 = 0), sds
 = c(1, 2, 1), rho = c(0, 0, 0), stde = 10, beta = c(0, -3, 4, 0), verbose
 = FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

That creates a new matrix with variables 
\begin_inset Formula $x1,$
\end_inset

 
\begin_inset Formula $x2$
\end_inset

, 
\begin_inset Formula $x3$
\end_inset

, and y.
 We run some linear regressions and then create a categorical output variable
 for a logistic regression.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<createdata1, echo=T>>=
\end_layout

\begin_layout Plain Layout

m1 <- lm(y ~ x1 + x2, data = dat)
\end_layout

\begin_layout Plain Layout

m2 <- lm(y ~ x2, data = dat)
\end_layout

\begin_layout Plain Layout

m3 <- lm(y ~ x1 + x2 + x3, data = dat)
\end_layout

\begin_layout Plain Layout

## Create categorical variant
\end_layout

\begin_layout Plain Layout

myilogit <- function(x) exp(x)/(1 + exp(x))
\end_layout

\begin_layout Plain Layout

dat$y3 <- rbinom(100, size = 1, p = myilogit(scale(dat$y)))
\end_layout

\begin_layout Plain Layout

gm1 <- glm(y3 ~ x1 + x2, data = dat)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The outreg examples are offered in Tables 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Tab1"

\end_inset

 through 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Combined-OLSGLM"

\end_inset

.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Tab1"

\end_inset

 is the 
\begin_inset Quotes eld
\end_inset

tight format output for three models, obtained from 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
outreg(list(m1, m2, m3), centering="siunitx")
\end_layout

\end_inset

.
 On the other hand, as illustrated in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Tab2"

\end_inset

, the author can request a wide table (tight = FALSE) and provide more elaborate
 model labels and adjust the significance stars.
 In Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Combined-OLSGLM"

\end_inset

, observe that the linear and generalized linear model output peacefully
 co-exist, side-by-side.
 This output is, in my opinion, completely acceptable for inclusion in a
 professional presentation or conference paper.
 There are some warts in this output.
 
\end_layout

\begin_layout Standard
The default output from 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
outreg
\end_layout

\end_inset

 will have left-aligned columns.
 Because users requested decimal-centered columns, the argument centering
 has been introduced.
 If 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
centering="siunitx"
\end_layout

\end_inset

 or 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
centering=TRUE
\end_layout

\end_inset

, the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
outreg
\end_layout

\end_inset

 table will be adjusted to use features in the LaTeX package 
\begin_inset Quotes eld
\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout
siunitx
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
 The LaTeX package dcolumn is probably more familiar to users, and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
"dcolumn"
\end_layout

\end_inset

 is also a legal value for centering, but the results are not quite as good.
 As a 
\series bold
caution
\series default
, I hasten to mention that if a user asks for decimal-centered columns,
 the user has the duty to insert into the document preamble either 
\begin_inset Quotes eld
\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout

\backslash
usepackage{siunitx}
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout

\backslash
usepackage{dcolumn}
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Decimal-centered columns in the 
\begin_inset Quotes eld
\end_inset

tight
\begin_inset Quotes erd
\end_inset

 style
\begin_inset CommandInset label
LatexCommand label
name "tab:Tab1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<outreg10, echo = F, results=tex>>=
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

or <- outreg(list(m1, m2, m3), centering = 
\begin_inset Quotes eld
\end_inset

siunitx
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The wide format obtained with tight = FALSE
\begin_inset CommandInset label
LatexCommand label
name "tab:Tab2"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<outreg20, results=tex, echo=F>>=
\end_layout

\begin_layout Plain Layout

or1 <- outreg(list("The First Model with a Long Title" = m1, "Another Model"
 = m3), tight = FALSE, alpha = c(0.05, 0.01, 0.001), centering = 
\begin_inset Quotes eld
\end_inset

siunitx
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Combined OLS and GLM Estimates
\begin_inset CommandInset label
LatexCommand label
name "tab:Combined-OLSGLM"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<outreg70, results=tex, echo=F>>=
\end_layout

\begin_layout Plain Layout

or2 <- outreg(list(m1,gm1), modelLabels = c("OLS:y","GLM: Categorized y"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
I understand that some authors need to include regression tables in documents
 that are not prepared with LaTeX.
 The parameter type = 
\begin_inset Quotes eld
\end_inset

HTML
\begin_inset Quotes erd
\end_inset

 will change the output format to HTML.
 An HTML file can be displayed in a web browser and it can be imported in
 traditional 
\begin_inset Quotes eld
\end_inset

word processor
\begin_inset Quotes erd
\end_inset

 programs.
\end_layout

\begin_layout Section
Plotting Regressions with Interactions 
\end_layout

\begin_layout Subsection
Interaction in Linear Regression.
 
\end_layout

\begin_layout Standard
One of the most fundamental skills in regression analysis is the interpretation
 of interactive predictors.
 It is much easier for students to understand the effect of an interaction
 if they can create a nice plot to show how the predicted value depends
 on various values of a predictor.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
plotSlopes()
\end_layout

\end_inset

 function was introduced in 2010 when I was teaching a large first-year
 graduate course (more than 50 students) and it became apparent that about
 20 percent of them would not be able to manage the R coding required to
 draw several lines on a single plot.
 Unfortunately, R's termplot() function will not draw regressions involving
 interactions.
\end_layout

\begin_layout Standard
The rockchalk package has two functions to help with this, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
plotSlopes()
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
plotCurves()
\end_layout

\end_inset

.
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
plotCurves()
\end_layout

\end_inset

 is more general, it can handle any kind of formula that the user estimates.
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
plotSlopes()
\end_layout

\end_inset

 is more limited, it is only for lm objects.
 In return for that limitation, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
plotSlopes()
\end_layout

\end_inset

 creates an output object which can be used to conduct post-hoc hypothesis
 tests.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<ps05, fig=T, echo=F, include=F, height=5, width=6>>=
\end_layout

\begin_layout Plain Layout

m1ps <- plotSlopes(m1, plotx = "x2", xlab = "x2 from model m1", interval
 = "confidence", opacity = 80, col = "red", ylim = c(20, 70))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
includegraphics[height=4in]{rockchalk-ps05}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
plotSlopes: Linear Model with Confidence Interval
\begin_inset CommandInset label
LatexCommand label
name "fig:ps05"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
At its most elementary level, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
plotSlopes()
\end_layout

\end_inset

 is a 
\begin_inset Quotes eld
\end_inset

one step
\begin_inset Quotes erd
\end_inset

 regression line plotter.
 If the regression model includes more than one predictor, then a single
 predictor is displayed on the horizontal axis and the other predictors
 are set on their central values.
 A plot for the model m1, that was illustrated above, is presented in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ps05"

\end_inset

.
 In rockchalk-1.8, new arguments were added to allow the 
\begin_inset Quotes eld
\end_inset

see though
\begin_inset Quotes erd
\end_inset

 confidence region.
 The command to generate Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ps05"

\end_inset

 was
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=T, eval=F>>=
\end_layout

\begin_layout Plain Layout

<<ps05>>
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
I've adjusted the color and opacity to illustrate the usage of those arguments.
 The y range is adjusted to make a little extra room for the legend.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\noindent
plotSlopes()
\end_layout

\end_inset

 function is very flexible.
 All of the label, color, and scale arguments of a plot function are also
 available.
 The plotSlopes function also works well if the moderator is a categorical
 variable.
 
\end_layout

\begin_layout Standard
It is important to note that the output object, m1ps, has the information
 necessary to re-create the plotted line in the form of a 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
newdata
\end_layout

\end_inset

 data frame.
 The first few lines in the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
newdata
\end_layout

\end_inset

 object are
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

m1ps$newdata[1:3, ]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<ps09, fig=F, echo=F, height=9, width=6>>=
\end_layout

\begin_layout Plain Layout

dat$y4 <- 1 + 0.1 * dat$x1 - 6.9 * dat$x2 + 0.5 * dat$x1*dat$x2 + 0.2 * dat$x3
 + rnorm(100, m = 0, sd = 10)
\end_layout

\begin_layout Plain Layout

m4 <- lm(y4 ~ x1*x2 + x3, data = dat)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<ps10, fig=T, echo=F, height=9, width=6>>=
\end_layout

\begin_layout Plain Layout

par(mfcol=c(2,1))
\end_layout

\begin_layout Plain Layout

m4psa <- plotSlopes(m4, plotx = "x1", modx = "x2", xlab = "x1 is a fun plotx")
\end_layout

\begin_layout Plain Layout

m4psb <- plotSlopes(m4, plotx = "x2", modx = "x1", modxVals = "std.dev.",
 xlab = "x2 is plotx", ylim = c(-100, 20))
\end_layout

\begin_layout Plain Layout

par(mfcol=c(1,1))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
plotSlopes Illustrated
\begin_inset CommandInset label
LatexCommand label
name "fig:ps10"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is more interesting if we fit a regression with an interaction term,
 such as 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

m4 <- lm(y4 ~ x1*x2 + x3, data = dat)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
We then ask 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\noindent
plotSlopes
\end_layout

\end_inset

 to draw the predicted values using one numeric variable as the horizontal
 axis and values of another variable (a moderator) are set at particular
 values.
 Either x1 or x2 can be viewed as the 
\begin_inset Quotes eld
\end_inset

moderator
\begin_inset Quotes erd
\end_inset

 predictor, the one on which the effect of the other depends.
 In rockchalk version 1.8, the selection of values of the moderator was generaliz
ed, so that the user can specify either a function that selects values,
 or a vector of values, or the name of an algorithm.
 The default algorithm will choose quantile values, but Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ps10"

\end_inset

 demonstrates also the 
\begin_inset Quotes eld
\end_inset

std.dev.
\begin_inset Quotes erd
\end_inset

 divider algorithm.
 The code to produce that figure was
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F, echo=T>>=
\end_layout

\begin_layout Plain Layout

<<ps10>>
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
modx
\end_layout

\end_inset

 is a numeric variable, then some particular values must be selected for
 calculation of predicted value lines.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
modxVals
\end_layout

\end_inset

 argument is used to either specify moderator values or an algorithm to
 select focal values.
 By default, three hypothetical values of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
plotx
\end_layout

\end_inset

 are selected (the quantiles 25%, 50%, and 75%).
 
\end_layout

\begin_layout Standard
If 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
modx
\end_layout

\end_inset

 is a factor variable, then the most frequently observed scores will be
 selected for consideration.
 The default display will include the regression line as well as color-coded
 points for the subgroups represented by values of the moderator.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=F>>=
\end_layout

\begin_layout Plain Layout

fourCat <- gl(4,25, labels=c("East","West","South", "Midwest"))
\end_layout

\begin_layout Plain Layout

dat$x4 <- sample(fourCat, 100, replace = TRUE)
\end_layout

\begin_layout Plain Layout

dat$y5 <- 1 + 0.1 * dat$x1 + contrasts(dat$x4)[dat$x4, ] %*% c(-1,1,2) +
 rnorm(100,0, sd=10)
\end_layout

\begin_layout Plain Layout

m5 <- lm (y5 ~ x1*x4 + x3, data=dat)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<ps20, fig=T, echo=F>>=
\end_layout

\begin_layout Plain Layout

m5psa <- plotSlopes(m5, plotx = "x1", modx = "x4", xlab = "x1 is a Continuous
 Predictor", xlim = magRange(dat$x1, c(1.2,1)))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
plotSlopes with a Categorical Moderator
\begin_inset CommandInset label
LatexCommand label
name "fig:ps20"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<ps21, fig=T, echo=F>>=
\end_layout

\begin_layout Plain Layout

m5psb <- plotSlopes(m5, plotx = "x1", modx = "x4", modxVals = c("West","East"),
 xlab = "x1 is a Continuous Predictor", xlim=magRange(dat$x1, c(1.2,1)),
 interval = "conf")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
plotSlopes: the interval argument
\begin_inset CommandInset label
LatexCommand label
name "fig:ps21"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

Suppose we have a four-valued categorical variable, 
\begin_inset Quotes eld
\end_inset

West
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

Midwest
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

South
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

East
\begin_inset Quotes erd
\end_inset

.
 If that variable is used in an interaction in the regression model, then
 the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\noindent
plotSlopes
\end_layout

\end_inset

 output will include four lines, one for each region.
 For example, consider Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ps20"

\end_inset

, which is created by
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

<<ps20>>
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The categorical variable is x4.
 
\end_layout

\begin_layout Standard
It is possible to superimpose confidence intervals for many subgroups, but
 sometimes these plots start to look a little bit 
\begin_inset Quotes eld
\end_inset

busy
\begin_inset Quotes erd
\end_inset

.
 The mixing of shades in overlapping intervals may help with that problem.
 A plot that focuses on just two subgroups is presented in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ps21"

\end_inset

, which is produced by 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

<<ps21>>
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
In rockchalk version 1.8, I've exerted quite a bit of effort to make sure
 that colors are chosen consistently when users remove or insert groups
 in these plots.
 The same value of the moderator should always be plotted in the same way–the
 line, points, and interval colors should not change.
 Note, for example, in Figures 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ps20"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ps21"

\end_inset

, the line for East is black in both plots, while the line for West is red
 in both.
 
\end_layout

\begin_layout Subsection
testSlopes, a companion of plotSlopes
\end_layout

\begin_layout Standard
The students in psychology and political science are usually interested
 in conducting some diagnostic analysis of the interactive terms.
 
\begin_inset CommandInset citation
LatexCommand citet
key "Aiken1991"
literal "true"

\end_inset

 (and later 
\begin_inset CommandInset citation
LatexCommand citealp
key "Cohen2002"
literal "true"

\end_inset

Cohen, Cohen, West, and Aiken) propose using the t test to find out if the
 effect of the 
\begin_inset Quotes eld
\end_inset

plotx
\begin_inset Quotes erd
\end_inset

 variable is statistically significantly different from zero for each particular
 value of the moderator variable.
 The new version of rockchalk declares a method plot.testSlopes that handles
 the work of plotting the interaction.
\end_layout

\begin_layout Standard
The usual case would be the following.
 First, carry out the regression analysis.
 Then run plotSlopes, and run testSlopes, and then pass that result object
 to the plot method.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<ts10, fig=T, echo=F, height=6, width=6>>=
\end_layout

\begin_layout Plain Layout

m4psats <- testSlopes(m4psa)
\end_layout

\begin_layout Plain Layout

plot(m4psats)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
testSlopes for an Interactive Model
\begin_inset CommandInset label
LatexCommand label
name "fig:ts10"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

m4 <- lm(y ~ x1*x2 + x3, data = dat)
\end_layout

\begin_layout Plain Layout

m4ps <- plotSlopes(m4, plotx = "x1", modx ="x2", xlab = "x1 is a Continuous
 Predictor")
\end_layout

\begin_layout Plain Layout

m4psats <- testSlopes(m4ps)
\end_layout

\begin_layout Plain Layout

plot(m4psats)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The output from testSlopes will differ, depending on whether modx is numeric
 or a factor.
 If it is a factor, then the slope of the lines and the associated t-test
 for each will be presented.
 My psychology students call these 
\begin_inset Quotes eld
\end_inset

simple-slopes
\begin_inset Quotes erd
\end_inset

, following the terminology of Aiken and West.
 The general idea is that we want to know if the 
\begin_inset Quotes eld
\end_inset

combined
\begin_inset Quotes erd
\end_inset

 effect of plotx is not zero.
 For a model stated with predictors 
\begin_inset Formula $plotx_{i}$
\end_inset

 and 
\begin_inset Formula $modx_{i}$
\end_inset

as
\begin_inset Formula 
\begin{equation}
y_{i}=b_{0}+b_{plotx}plotx_{i}+b_{modx}modx_{i}+b_{plotx:modx}plotx_{i}\cdot modx_{i}+\ldots+e_{i}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
the null hypothesis would be
\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{equation}
H_{0}:0=\hat{b}_{simple\,slope}=\hat{b}_{plotx}+\hat{b}_{plotx:modx}modx
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
If modx is a factor, then we simply calculate the slope of each line and
 the test is straight-forward.
 If modx is a numeric variable, then we confront a problem that is a bit
 more interesting.
 We don't really want to say that the simple slope is different from 0 for
 particular values of 
\begin_inset Formula $modx$
\end_inset

, but instead we want to answer the question, 
\begin_inset Quotes eld
\end_inset

for which values of the moderator would the effect of the plotx variable
 be statistically significant?
\begin_inset Quotes erd
\end_inset

.
 This necessitates the calculation of the so-called Johnson-Neyman interval
 (
\begin_inset CommandInset citation
LatexCommand citeyear
key "JohnsonNeyman1936"
literal "true"

\end_inset

), a plot of which is presented in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ts10"

\end_inset

.
\end_layout

\begin_layout Standard
The method of calculation is outlined in 
\begin_inset CommandInset citation
LatexCommand citet
key "PreacherCurren2006"
literal "true"

\end_inset

.
 The values of 
\begin_inset Formula $modx$
\end_inset

 associated with a statistically significant effect of 
\begin_inset Formula $plotx$
\end_inset

 on the outcome is determined from the computation of a T statistic for
 
\begin_inset Formula $\hat{b}_{simple\,slope}$
\end_inset

.
 The J-N interval is the set of values of 
\begin_inset Formula $modx$
\end_inset

 for which the following (quadratic equation) holds:
\begin_inset Formula 
\begin{equation}
\hat{t}=\frac{\hat{b}_{simple\,slope}}{std.err(\hat{b}_{simple\,slope})}=\frac{\hat{b}_{simple\,slope}}{\sqrt{\widehat{Var(\hat{b}_{plotx})}+modx^{2}\widehat{Var(\hat{b}_{plotx\cdot modx})}+2modx\widehat{Cov(\hat{b}_{plotx},\hat{b}_{plotx\cdot modx})}}}\geq T_{\frac{\alpha}{2},df}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Suppose there are two real roots, 
\begin_inset Formula $root1$
\end_inset

 and 
\begin_inset Formula $root2$
\end_inset

.
 The values of 
\begin_inset Formula $modx$
\end_inset

 for which the slope is statistically significant may be a compact interval,
 
\begin_inset Formula $[root1,root2]$
\end_inset

, as demonstrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ts10"

\end_inset

, or it may two open intervals, 
\begin_inset Formula $(-\infty,root1]$
\end_inset

 and 
\begin_inset Formula $[root2,\infty)$
\end_inset

.
 I had expected almost all applications to result in that latter case, but
 the somewhat surprising case illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ts10"

\end_inset

 is not too infrequently observed.
 
\end_layout

\begin_layout Subsection
plotCurves for nonlinear predictor formulae
\end_layout

\begin_layout Standard
plotCurves() generalizes the plotting capability of plotSlopes.
 plotCurves() should be able to handle any regression formulas that include
 nonlinear transformations.
 Models that have polynomials or terms that are logged (or otherwise transformed
) can be plotted.
 In that sense, plotCurves() is rather similar to R's own termplot() function,
 but plotCurves() has two major advantages.
 First, it allows interactions, and second, it handles some complicated
 formulae that termplot() is not able to manage.
 
\end_layout

\begin_layout Standard
Suppose a dependent variable y5 is created according to a nonlinear process.
\begin_inset Formula 
\begin{equation}
y5_{i}=-3x1_{i}+7*log(x2)+1.1x2_{i}+2.2x1_{i}\times x2_{i}+e_{i}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=F,include=F>>=
\end_layout

\begin_layout Plain Layout

dat$y5 <- with(dat, -3*x1 + 15*log(0.1 + x2 - min(x2)) + 1.1*x2 + 8.2 *x1 *
 x2 + 10*rnorm(100))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<pcps20, fig=T, echo = F, height=6, width=6>>=
\end_layout

\begin_layout Plain Layout

m5 <- lm(y5 ~ log(x2) + x1 * x2, data = dat)
\end_layout

\begin_layout Plain Layout

m5pc <- plotCurves(m5, plotx = "x2", modx = "x1")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
plotCurves
\begin_inset CommandInset label
LatexCommand label
name "fig:pcps20"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We fit a model with an elaborate specification and create the plot in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pcps20"

\end_inset

 with these commands:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

<<pcps20>>
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
plotPlane
\end_layout

\begin_layout Standard
The persp function in R works well, but its interface is too complicated
 for most elementary and intermediate R users.
 To facilitate its use for regression users, the plotPlane() function is
 offered.
\end_layout

\begin_layout Standard
The plotPlane function offers a visualization of the mutual effect of two
 predictors, whether or not the regression model is linear.
 plotPlane() is designed to work like plotCurves(), to tolerate nonlinear
 components in the regression formula.
 plotPlane() allows the depiction of a 3 dimensional curving plane that
 
\begin_inset Quotes eld
\end_inset

sits
\begin_inset Quotes erd
\end_inset

 in the cloud of data points.
 The variables that are not explicitly pictured in the plotPlane() figure
 are set to central reference values.
 Recall model m4, which used the formula 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y4 ~ x1*x2 + x3
\end_layout

\end_inset

.
 As illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pp100"

\end_inset

, plotCurves() presents a reasonable view of the predicted values.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<pp100, fig=T, echo=F>>=
\end_layout

\begin_layout Plain Layout

p100 <- plotPlane(m4, plotx1 = "x1", plotx2 = "x2", phi = 10, theta = -80,
 lcol = gray(.70))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
plotPlane for the Interactive Model m4
\begin_inset CommandInset label
LatexCommand label
name "fig:pp100"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Because plotPlane() is a simple convenience wrapper for R's persp() function,
 it responds to the same customizing arguments that perp would allow.
 The arguments phi and theta will rotate the figure, for example.
 The output in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pp100"

\end_inset

 is produced by the following.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=T,eval=F>>=
\end_layout

\begin_layout Plain Layout

<<pp100>>
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
One of the major educational benefits of the 3-D figure is that students
 can easily see that a model with a simple interaction effect is 
\emph on
not a linear model any more.
 
\emph default
We will return to that point in the discussion of mean centering in regression
 analysis.
\end_layout

\begin_layout Standard
Recall that model m5 is the rather complicated nonlinear formula 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

log(x2*x2) + x1 * x2
\end_layout

\end_inset

.
 The plotCurves() output for that was already presented in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pcps20"

\end_inset

.
 The three dimensional view of the same is presented in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pp110"

\end_inset

, but with an added twist.
 The twist is that the predicted value lines from the 2-D plot functions
 can be superimposed on the plane.
 The function addLines() does the work for translating 2-D plot object onto
 the regression plane.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<pp111, fig = T, echo = F, height = 5, results = hide>>=
\end_layout

\begin_layout Plain Layout

ppm5 <- plotPlane(m5, plotx1 = "x2", plotx2 = "x1", phi = 0, npp = 15, lcol
 = gray(.80))
\end_layout

\begin_layout Plain Layout

addLines(from = m5pc, to = ppm5, col = m5pc$col)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Making plotSlopes and plotPlane Work Together
\begin_inset CommandInset label
LatexCommand label
name "fig:pp110"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Standardized, Mean-Centered, and Residual-Centered Regressions 
\end_layout

\begin_layout Subsection
Standardized regression
\end_layout

\begin_layout Standard
Many of us learned to conduct regression analysis with SPSS, which reported
 both the ordinary (unstandardized) regression coefficients as well as a
 column of 
\begin_inset Quotes eld
\end_inset

beta weights
\begin_inset Quotes erd
\end_inset

, the output of a 
\begin_inset Quotes eld
\end_inset

standardized
\begin_inset Quotes erd
\end_inset

 regression analysis.
 Each variable, for example 
\begin_inset Formula $x1_{i}$
\end_inset

, was replaced by an estimated 
\begin_inset Formula $Z-score:$
\end_inset

 
\begin_inset Formula $(x1_{i}-\overline{x1})/std.dev.(x1_{i}$
\end_inset

).
 Some people think these coefficients are easier to interpret (but, for
 a strong cautionary argument against them, see 
\begin_inset CommandInset citation
LatexCommand citealp
key "King1986"
literal "true"

\end_inset

).
 R offers no such thing as standardized regression, probably because this
 practice is practice is thought to be mistaken.
 The automatic standardization of all predictors, no matter whether they
 are categorical, interaction terms, or transformed values (such as logs)
 is dangerous.
 
\end_layout

\begin_layout Standard
To illustrate that, the rockchalk introduces a function called standardize().
 Each column of the design matrix is scaled to a new variable with mean
 0 and standard deviation 1.
 The result from standardize() will be an R lm object, which will respond
 to any follow-up analysis commands.
 For example:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

m4 <- lm (y4 ~ x1 * x2, data = dat)
\end_layout

\begin_layout Plain Layout

m4s <- standardize(m4)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I doubt that a reasonable person would actually want a standardized regression
 and have tried to warn users in the output.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

summary(m4s)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Comparing Ordinary and Standardized Regression
\begin_inset CommandInset label
LatexCommand label
name "tab:stdreg10"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<stdreg10, results=tex, echo=F>>=
\end_layout

\begin_layout Plain Layout

or10 <- outreg(list(m4, m4s), tight = F, modelLabels = c("Not Standardized","Sta
ndardized"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Mean-centered Interaction Models
\end_layout

\begin_layout Standard
Sometimes people will fit a model like this
\begin_inset Formula 
\begin{equation}
y_{i}=b_{o}+b_{1}x1_{i}+b_{2}x2_{i}+e_{i}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
and then wonder, 
\begin_inset Quotes eld
\end_inset

is there an interaction between 
\begin_inset Formula $x1_{i}$
\end_inset

 and 
\begin_inset Formula $x2_{i}$
\end_inset

?
\begin_inset Quotes erd
\end_inset

 The natural inclination is to run this model, 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

m1 <- lm(y ~ x1*x2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
or its equivalent
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

m2 <- lm(y ~ x1 + x2 + x1:x2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Researchers have been advised that they should not run the ordinary interaction
 model without 
\begin_inset Quotes eld
\end_inset

mean-centering
\begin_inset Quotes erd
\end_inset

 the predictors (Aiken and West, 1991).
 They are advised to replace 
\begin_inset Formula $x1_{i}$
\end_inset

 with 
\begin_inset Formula $(x1_{i}-\overline{x1})$
\end_inset

 and 
\begin_inset Formula $x2_{i}$
\end_inset

 with 
\begin_inset Formula $(x2_{i}-\overline{x2})$
\end_inset

, so that the fitted model will
\begin_inset Formula 
\begin{equation}
y_{i}=b_{o}+b_{1}(x1_{i}-\overline{x1})+b_{2}(x2_{i}-\overline{x2})+b_{3}(x1_{i}-\overline{x1})(x2_{i}-\overline{x2})+e_{i}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
This is a little tedious to do in R, so I provide a function meanCenter()
 that can handle the details.
 meanCenter() will receive a model, scan it for interaction terms, and then
 center the variables that are involved in interactions.
 We previously fit the model m4, and now we center it.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

m4mc <- meanCenter(m4)
\end_layout

\begin_layout Plain Layout

summary(m4mc)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
By default, meanCenter() will only center the variables involved in an interacti
on, and it leaves the others unchanged.
 The user can request a different treatment of the variables.
 Version 1.8 introduces the argument 
\begin_inset Quotes eld
\end_inset

terms
\begin_inset Quotes erd
\end_inset

, which allows the user to list the names of the predictors that should
 be centered.
 If the user wants all of the numeric predictors to be mean-centered, the
 usage of the argument centerOnlyInteractors would be appropriate:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

m4mc <- meanCenter(m4, centerOnlyInteractors = FALSE)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
By default, it does not standardize while centering (but the user can request
 standardization with the argument standardize = TRUE.
 The option centerDV causes the dependent variable to be centered as well.
\end_layout

\begin_layout Subsection
Residual-centered Models
\end_layout

\begin_layout Standard
Residual-centering 
\begin_inset CommandInset citation
LatexCommand citep
key "LittleBovaird2006"
literal "true"

\end_inset

is another adjustment that has been recommended for models that include
 interactions or squared terms.
 Like mean-centering, it is often recommended as a way to obtain smaller
 standard errors or to make estimates more numerically stable.
 Like mean centering, it causes a completely superficial change in the estimated
 coefficients.
 Nothing of substance is altered.
\end_layout

\begin_layout Standard
The residualCenter() function is used in the same manner as meanCenter().
 The user fits an interactive model and the result object is passed to residualC
enter() like so:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

m4rc <- residualCenter(m4)
\end_layout

\begin_layout Plain Layout

summary(m4rc)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I would explain residual-centering as follows.
 Suppose we fit the linear model, with no interaction (note, I'm calling
 the coefficients 
\begin_inset Formula $c_{j}$
\end_inset

, not 
\begin_inset Formula $b_{j}$
\end_inset

 as usual):
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
y=c_{0}+c_{1}x1+c_{2}x2+e{}_{i}.\label{eq:rc20}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Let's proceed as if those parameter estimates, 
\begin_inset Formula $\hat{c}_{1}$
\end_inset

, 
\begin_inset Formula $\hat{c}_{2}$
\end_inset

, are the 
\begin_inset Quotes eld
\end_inset

right ones
\begin_inset Quotes erd
\end_inset

 for our analytical purpose.
 We'd like to fit an interactive model, but protect the linear parts from
 fluctuation.
 In R, when we run th 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

lm(y ~ x1 * x2)
\end_layout

\end_inset

, we are allowing all of the coefficients to fluctuate 
\begin_inset Formula 
\begin{equation}
y_{i}=b_{o}+b_{1}x1_{i}+b_{2}x2_{i}+b_{3}x1_{i}\times x2_{i}+e_{i}\label{eq:rcwant}
\end{equation}

\end_inset

Residual centering is one way to stabilize the estimation by assuring that
 
\begin_inset Formula $\hat{b}_{1}=\hat{c}_{1}$
\end_inset

 and 
\begin_inset Formula $\hat{b}_{2}=\hat{c}_{2}$
\end_inset

.
 Only the coefficient 
\begin_inset Formula $\hat{b}_{3}$
\end_inset

 floats freely.
\end_layout

\begin_layout Standard
One of the reasons that residual-centering is so appealing is that its stabilizi
ng benefit is obtained almost by accident.
 Here is the gist of the calculations.
 First, estimate a regression in which the left hand side is the interaction
 product term:
\begin_inset Formula 
\begin{equation}
(x1_{i}\times x2_{i})=d_{0}+d_{1}x1_{i}+d_{2}x2+u_{i}\label{eq:residCentered}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The residuals from that regression are, by definition, orthogonal to both
 
\begin_inset Formula $x1$
\end_inset

 and 
\begin_inset Formula $x2$
\end_inset

.
 Call those fitted residuals 
\begin_inset Formula $\widehat{u_{i}}$
\end_inset

.
 The we run the interactive regression, replacing the column of the predictor
 
\begin_inset Formula $x1_{i}\times x2_{i}$
\end_inset

, with 
\begin_inset Formula $\widehat{u}_{i}$
\end_inset

.
 That is to say, the model we want, equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rcwant"

\end_inset

), is estimated as: 
\begin_inset Formula 
\begin{equation}
y_{i}=b_{0}+b_{1}x1_{i}+b_{2}x2_{i}+b3\widehat{u_{i}}+e_{i},\label{eq:rc10-1}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
In essence, we have taken the interaction 
\begin_inset Formula $(x1_{i}\times x2_{i})$
\end_inset

, and purged it of its parts that are linearly related to 
\begin_inset Formula $x1_{i}$
\end_inset

 and 
\begin_inset Formula $x2_{i}$
\end_inset

.
 
\end_layout

\begin_layout Standard
rockchalk 1.6 included summary, print, and predict methods for the residual-cente
red regression objects.
 It is worth mentioning that the code can handle interactions of arbitrarily
 many predictors.
 If the formula has 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

lm(y ~ x1 * x2 * x3 * x4)
\end_layout

\end_inset

, for example, this implies many separate interactions must be calculated.
 We need to calculate residual-centered residuals for 
\begin_inset Formula $x1\cdot x2$
\end_inset

, 
\begin_inset Formula $x1\cdot x3$
\end_inset

, 
\begin_inset Formula $x1\cdot x4$
\end_inset

, 
\begin_inset Formula $x2\cdot x3$
\end_inset

 and so forth, and then use them as predictors to get centered estimates
 of terms 
\begin_inset Formula $x1\cdot x2\cdot x3$
\end_inset

, and then their centered values are predictors four term interactions.
 Aspiring R programmers who want to learn about programming with R formula
 objects might benefit from the study of the function residualCenter.R in
 the rockchalk source code.
 
\end_layout

\begin_layout Section
A Brief Analysis of Mean-Centering
\end_layout

\begin_layout Standard
We can put the tools together by making a little detour into the question
 that seems to plague every regression analyst at one time or another: What
 does that interaction term 
\emph on
really mean
\emph default
? Along the way, we will try to dispel the idea that centering somehow makes
 estimates 
\begin_inset Quotes eld
\end_inset

better
\begin_inset Quotes erd
\end_inset

 or more numerically precise.
 The primary advocates of centering as a way to deal with numerical instability
 are 
\begin_inset CommandInset citation
LatexCommand citet
key "Aiken1991"
literal "true"

\end_inset

, who integrated that advice into the very widely used regression textbook,
 
\emph on
Applied Multiple Regression/Correlation for the Behavioral Sciences
\emph default
 
\begin_inset CommandInset citation
LatexCommand citep
key "Cohen2002"
literal "true"

\end_inset

.
 They claim that the inclusion of interactions causes 
\begin_inset Quotes eld
\end_inset

inessential multicollinearity
\begin_inset Quotes erd
\end_inset

 that is alleviated by centering.
 The advice is widely followed.
 One statistics book intended for biologists observed, for example, 
\begin_inset Quotes eld
\end_inset

We support the recommendation of Aiken & West (1991) and others that multiple
 regression with interaction terms should be fitted to data with centered
 predictor values
\begin_inset Quotes erd
\end_inset

 (
\begin_inset CommandInset citation
LatexCommand citealp
key "QuinnKeough2002"
literal "true"

\end_inset

, Chapter 6).
 
\end_layout

\begin_layout Standard
Technical rebuttals have been published already (
\begin_inset CommandInset citation
LatexCommand citealp
key "Kromrey1998"
literal "true"

\end_inset

), but the matter still seems not widely understood.
 The argument is not that mean-centering (or residual-centering) is wrong,
 but rather that it is unnecessary.
 It is irrelevant, and possibly, misleading.
\end_layout

\begin_layout Standard
At the core of the matter is the fact that our uncertainty about regression
 estimates depends on our point of view.
 Please review the confidence interval in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ps05"

\end_inset

.
 The 
\begin_inset Formula $y$
\end_inset

 axis is not even 
\begin_inset Quotes eld
\end_inset

in the picture.
\begin_inset Quotes erd
\end_inset

 Would one's appreciation of the regression's predictive line be enhanced
 if the y axis were moved into the picture? 
\end_layout

\begin_layout Standard
We can move the 
\begin_inset Formula $y$
\end_inset

 axis by centering the predictor variable.
 Suppose we replace 
\begin_inset Formula $x_{i}$
\end_inset

 with 
\begin_inset Formula $x_{i}-5$
\end_inset

 and then re-estimate the model.
 That has the simple effect of moving the 
\begin_inset Formula $y$
\end_inset

 axis 5 units to the right.
 The slope is unchanged, and the reported intercept is changed in a completely
 superficial way.
 The predicted value line, the slope estimates, the residual standard error,
 and so forth, are not changed in any substantial way.
 This is simply a matter of user convenience.
 I believe that no reasonable person can say the regression is 
\begin_inset Quotes eld
\end_inset

better
\begin_inset Quotes erd
\end_inset

 after centering 
\begin_inset Formula $x_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
However, there is a superficial difference that has deceived many authors.
 Notice that the confidence interval is hourglass shaped.
 
\emph on
At the new 
\begin_inset Formula $y$
\end_inset

 axis
\emph default
, our prediction is more precise.
 If we move the y axis further to the right, into the center of the data,
 say by mean-centering (
\begin_inset Formula $x_{i}-10$
\end_inset

), we move to the position that allows an even more precise prediction.
 The estimate of the intercept's standard error will be smaller for the
 obvious reason.
 We are not actually gaining certainty, we are simply reporting our most
 favorable 
\begin_inset Quotes eld
\end_inset

snapshot
\begin_inset Quotes erd
\end_inset

 of it.
 The predicted value, and the confidence interval for any observed value
 of 
\begin_inset Formula $x_{i}$
\end_inset

 is completely unchanged by centering.
\end_layout

\begin_layout Standard
It should not surprise the reader to learn that mean-centering interactive
 predictors enhances the standard errors in the same illusory way.
 Let's work though an example to see why this is so tempting.
 Suppose the true data generating mechanism is an interaction like so
\begin_inset Formula 
\begin{equation}
y_{i}=2+0.1x1_{i}+0.1x2_{i}+0.2\cdot(x1_{i}\times x2_{i})+e_{i},
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $e_{i}\sim N(0,300^{2})$
\end_inset

 and 
\begin_inset Formula $\rho_{x1,x2}=0.4$
\end_inset

.
 
\end_layout

\begin_layout Standard
A regression analysis that ignores the interaction, 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lm(y ~ x1 + x2, data = dat2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
is reported in the first column of Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:meancenter10-1"

\end_inset

.
 I've used outreg's new alpha argument to emphasize the 
\begin_inset Quotes eld
\end_inset

really good
\begin_inset Quotes erd
\end_inset

 estimates with more stars.
 Notice that everything is 
\begin_inset Quotes eld
\end_inset

statistically significant!
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Unable to leave well enough alone, the researcher wonders, 
\begin_inset Quotes eld
\end_inset

is there an interaction between 
\begin_inset Formula $x1$
\end_inset

 and 
\begin_inset Formula $x2$
\end_inset

?
\begin_inset Quotes erd
\end_inset

 Run 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lm(y ~ x1 * x2, data = dat2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The second column in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:meancenter10-1"

\end_inset

 summarizes that regression.
 Be prepared for a shock when you scan the estimates.
 Almost everybody I know has said 
\begin_inset Quotes eld
\end_inset

what the heck?
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Holy Cow!
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Oh My God, my great result went to Hell, I'll never get tenure!
\begin_inset Quotes erd
\end_inset

 Neither of the key variables is 
\begin_inset Quotes eld
\end_inset

statistically significant
\begin_inset Quotes erd
\end_inset

 any more.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=F, include=F>>=
\end_layout

\begin_layout Plain Layout

dat2 <- genCorrelatedData(N=400, rho=.4, stde=300, beta=c(2,0.1,0.1,0.2))
\end_layout

\begin_layout Plain Layout

m6linear <- lm (y ~ x1 + x2, data=dat2)
\end_layout

\begin_layout Plain Layout

m6int <- lm (y ~ x1 * x2, data=dat2)
\end_layout

\begin_layout Plain Layout

m6mc <- meanCenter(m6int)
\end_layout

\begin_layout Plain Layout

m6rc <- residualCenter(m6int)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Comparing Regressions
\begin_inset CommandInset label
LatexCommand label
name "tab:meancenter10-1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<mcenter10, results=tex, echo=F>>=
\end_layout

\begin_layout Plain Layout

or11 <- outreg(list(m6linear, m6int, m6mc, m6rc), tight=F, modelLabels=c("Linear
", "Interaction","Mean-centered","Residual-centered"), alpha = c(0.05, 0.01))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cohen, et al.
 claim that the apparent instability of the coefficients is a reflection
 of 
\begin_inset Quotes eld
\end_inset

inessential collinearity,
\begin_inset Quotes erd
\end_inset

 due to the fact that 
\begin_inset Formula $x1$
\end_inset

 and 
\begin_inset Formula $x2$
\end_inset

 are correlated with the new term, 
\begin_inset Formula $x1\times x2$
\end_inset

.
 They advised their readers to 
\begin_inset Quotes eld
\end_inset

mean-center
\begin_inset Quotes erd
\end_inset

 their predictors and run the regression again.
 
\end_layout

\begin_layout Standard
Remember the hourglass shape of the confidence interval.
 By mean-centering, we are re-positioning ourself for a much more favorable
 snapshot.
 The welcoming effect of the centered estimates is found in the third column
 of Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:meancenter10-1"

\end_inset

.
 The point estimates in that snapshot are 
\begin_inset Quotes eld
\end_inset

significant again.
\begin_inset Quotes erd
\end_inset

 It appears we have 
\begin_inset Quotes eld
\end_inset

solved
\begin_inset Quotes erd
\end_inset

 the problem of inessential collinearity.
 
\end_layout

\begin_layout Standard
The first hint of trouble is in the fact that the coefficients of the interactiv
e effects in columns 2 and 3 are identical.
 Those coefficients are the same because they are estimates of the cross
 partial derivative 
\begin_inset Formula $\partial^{2}y/\partial x1\partial x2$
\end_inset

.
 That particular value is the same, no matter where we position the 
\begin_inset Formula $y$
\end_inset

 axis, as it should be.
 Note as well that the root mean square and 
\begin_inset Formula $R^{2}$
\end_inset

 estimates are identical.
 Everything that we expect to remain the same is the same.
 Except for the fact that the slopes and their hypothesis tests seem better
 in the centered model, we would think there is nothing interesting here.
\end_layout

\begin_layout Standard
Here's a puzzle for you.
 Consider Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pscentering"

\end_inset

, which shows the predicted values and confidence intervals from the centered
 and uncentered regressions.
 Is there any substantively important difference between these two regressions?
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<pscenter, fig=T, echo=F, include = F, height = 10, width = 5, results
 = hide>>=
\end_layout

\begin_layout Plain Layout

par(mfcol = c(2, 1))
\end_layout

\begin_layout Plain Layout

plotSlopes(m6int, plotx = "x1", modx = "x2", modxVals = "std.dev.",  n = 2,
 interval = "confidence", main= "Not Centered")
\end_layout

\begin_layout Plain Layout

plotSlopes(m6mc, plotx = "x1c", modx = "x2c", modxVals = "std.dev.", n = 2,
 interval = "confidence", main = "Mean Centered")
\end_layout

\begin_layout Plain Layout

par(mfcol = c(1, 1))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
includegraphics[height=8in]{rockchalk-pscenter.pdf}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
plotSlopes for the centered and non-centered regressions
\begin_inset CommandInset label
LatexCommand label
name "fig:pscentering"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Perhaps the 2-D plots are not persuasive.
 Don't stop yet.
 In the 3-D plots will help quite a bit.
 We have not yet grasped the most fundamental changed caused by the insertion
 of the interaction term.
 When we insert 
\begin_inset Formula $x1_{i}\times x2_{i}$
\end_inset

, we change the fudamental nature of the regression surface.
 The surface of the fitted model is no longer a 
\begin_inset Quotes eld
\end_inset

flat
\begin_inset Quotes erd
\end_inset

 plane, but rather it is a curving surface.
 
\end_layout

\begin_layout Standard
I've assembled 3-D plots in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:mcenter30"

\end_inset

.
 We see that the ordinary interaction, mean-centered, and residual-centered
 models produce identical predicted values! The only difference in the figures
 is that the axes of the predictors have been re-scaled, so that the 
\begin_inset Formula $y$
\end_inset

 axis is (implicitly) re-positioned.
 Now that we understand the situation, we could play around with the data
 and move the axis back and forth until we arrive at a position that is
 most favorable to our interpretation.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<mcenter50, fig=T,echo=FALSE, height=5, width=7>>=
\end_layout

\begin_layout Plain Layout

op <- par(no.readonly = TRUE)
\end_layout

\begin_layout Plain Layout

par(mfcol=c(2,2))
\end_layout

\begin_layout Plain Layout

par(mar=c(2,2,2,1))
\end_layout

\begin_layout Plain Layout

plotPlane(m6linear, plotx1="x1", plotx2="x2", plotPoints=FALSE, main="Linear",
 ticktype="detailed")
\end_layout

\begin_layout Plain Layout

plotPlane(m6int, plotx1="x1", plotx2="x2", plotPoints=FALSE, main="Interaction:
 Not Centered", ticktype="detailed")
\end_layout

\begin_layout Plain Layout

plotPlane(m6mc, plotx1="x1c", plotx2="x2c", plotPoints=FALSE, main="Mean-centere
d", ticktype="detailed")
\end_layout

\begin_layout Plain Layout

plotPlane(m6rc, plotx1="x1", plotx2="x2", plotPoints=FALSE, main="Residual-cente
red", ticktype="detailed")
\end_layout

\begin_layout Plain Layout

par(op)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Predicted Planes from Centered and Uncentered Fits Identical
\begin_inset CommandInset label
LatexCommand label
name "fig:mcenter30"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The regression coefficient estimates are snapshots, each summarizing the
 curvature at one particular point in a curving surface.
 It seems quite apparent in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:mcenter30"

\end_inset

 that the models are identical, and yet we receive different regression
 reports from different spots.
 The non-centered data offers us the slope estimate from the 
\begin_inset Quotes eld
\end_inset

front-left
\begin_inset Quotes erd
\end_inset

 part of the graph.
 Mean-centered estimates report on the slope in the middle of the graph.
 In the rockchalk examples folder, one can find a file called 
\begin_inset Quotes eld
\end_inset

centeredRegression.R
\begin_inset Quotes erd
\end_inset

 that walks through this argument step by step.
 
\end_layout

\begin_layout Standard
What about residual-centering? Because the transformation that it employs
 is more abstract, I initially thought it was actually a different model.
 And yet it is not.
 The residual-centered model is completely equivalent to the ordinary interactio
n model and the mean-centered model.
 For a given combination of the input values, the predicted values and confidenc
e intervals are the same.
 The predicted values of the ordinary interactive model, the mean-centered
 model, and the residual-centered models are illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:rcenter40"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<rcenter40, fig=T,echo=FALSE, include=F, height=4, width=8>>=
\end_layout

\begin_layout Plain Layout

dat3 <- centerNumerics(dat2)
\end_layout

\begin_layout Plain Layout

##m6mcpred <- fitted(m6mc) ##
\end_layout

\begin_layout Plain Layout

m6mcpred <- predict(m6mc, newdata=dat3)
\end_layout

\begin_layout Plain Layout

##m6rcpred <- fitted(m6rc) ##
\end_layout

\begin_layout Plain Layout

m6rcpred <- predict(m6rc, newdata=dat3)
\end_layout

\begin_layout Plain Layout

##m6intpred <- fitted(m6int) ##
\end_layout

\begin_layout Plain Layout

m6intpred <- predict(m6int, newdata=dat3)
\end_layout

\begin_layout Plain Layout

op <- par(no.readonly = TRUE)
\end_layout

\begin_layout Plain Layout

par(mfcol=c(1,2))
\end_layout

\begin_layout Plain Layout

plot(m6intpred, m6rcpred, main="", xlab="Predictions of Uncentered Interaction",
 ylab="Residual-centered Predictions")
\end_layout

\begin_layout Plain Layout

predcor <- round(cor(m6intpred, m6rcpred),3)
\end_layout

\begin_layout Plain Layout

legend("topleft", legend=c(paste0("Correlation=", predcor)))
\end_layout

\begin_layout Plain Layout

plot(m6mcpred, m6rcpred, main="", xlab="Mean-centered Predictions", ylab
 = "Residual-centered Predictions")
\end_layout

\begin_layout Plain Layout

predcor <- round(cor(m6mcpred, m6rcpred),3)
\end_layout

\begin_layout Plain Layout

legend("topleft", legend=c(paste0("Correlation=", predcor)))
\end_layout

\begin_layout Plain Layout

par(op)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
includegraphics[width = 6.5in]{rockchalk-rcenter40}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Predicted Values of Mean and Residual-centered Models
\begin_inset CommandInset label
LatexCommand label
name "fig:rcenter40"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The take-away point from this is that there is no free lunch in regression
 analysis.
 If re-scaling a variable by adding or subtracting a constant seems to change
 a result, one should be cautious and suspect an error.
 
\end_layout

\begin_layout Standard
In order to drive the point home, I'd like to show that it is possible to
 translate between the estimates of any one of these fitted models and the
 estimates of the others.
 The ordinary model is
\begin_inset Formula 
\begin{equation}
y_{i}=b_{0}+b_{1}x1_{i}+b_{2}x2_{i}+b_{3}(x1_{i}\times x2_{i})+e1_{i}\label{eq:int}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The mean-centered model is 
\begin_inset Formula 
\begin{equation}
y_{i}=c_{0}+c_{1}(x1_{i}-\overline{x1})+c_{2}(x2_{i}-\overline{x2})+c_{3}(x1_{i}-\overline{x1})\cdot(x2_{i}-\overline{x2})+e2_{i}\label{eq:mc1}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
In order to compare with equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:int"

\end_inset

, we would re-arrange like so
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
y_{i}=c_{0}+c_{1}(x1_{i})-c_{1}\overline{x1}+c_{2}(x2_{i})-c_{2}\overline{x2}+c_{3}(x1_{i}x2_{i}+\overline{x1}\overline{x2}-\overline{x1}x2_{i}-\overline{x2}x1_{i})+e2_{i}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
y_{i}=c_{0}+c_{1}(x1_{i})-c_{1}\overline{x1}+c_{2}(x2_{i})-c_{2}\overline{x2}+c_{3}(x1_{i}x2_{i})+c_{3}\overline{x1}\overline{x2}-c_{3}\overline{x1}x2_{i}-c_{3}\overline{x2}x1_{i})+e2_{i}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
y_{i}=\{c_{0}-c_{1}\overline{x1}-c_{2}\overline{x2}+c_{3}\overline{x1}\overline{x2}\}+\{c_{1}-c_{3}\overline{x2}\}x1_{i}+\{c_{2}-c_{3}\overline{x1}\}x2_{i}+c_{3}(x1_{i}x2_{i})+e2_{i}\label{eq:mc3}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
One can then compare the parameter estimates from equations 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:int"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:mc3"

\end_inset

.
 Both 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:int"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:mc3"

\end_inset

 include a single parameter times 
\begin_inset Formula $(x1_{i}x2_{i}),$
\end_inset

 leading one to expect that the estimate 
\begin_inset Formula $\hat{b}_{3}$
\end_inset

 should be equal to the estimate of 
\begin_inset Formula $\hat{c}_{3}$
\end_inset

, and they are! Less obviously, one can use the fitted coefficients from
 either model to deduce the fitted coefficients from the other.
 The following equalities describe that relationship.
\begin_inset Formula 
\begin{eqnarray}
\hat{b}_{0} & = & \hat{c}_{0}-\hat{c}_{1}\overline{x1}-\hat{c}_{2}\overline{x2}+\hat{c}_{3}\overline{x1}\overline{x2}\\
\hat{b}_{1} & = & \hat{c}_{1}-\hat{c}_{3}\overline{x2}\\
\hat{b}_{2} & = & \hat{c}_{2}-\hat{c}_{3}\overline{x1}\\
\hat{b}_{3} & = & \hat{c}_{3}
\end{eqnarray}

\end_inset

The estimated fit of equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:mc1"

\end_inset

 would provide estimated coefficients 
\begin_inset Formula $\hat{c}_{j}$
\end_inset

, 
\begin_inset Formula $j=0,...,3$
\end_inset

, which would then be used to calculate the estimates from the non-centered
 model.
\end_layout

\begin_layout Standard
The estimation of the residual-centered model requires two steps.
 The residual from this regression model
\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{equation}
\widehat{(x1_{i}\times x2_{i})}=\hat{d}_{0}+\hat{d}_{1}x1_{i}+\hat{d}_{2}x2_{i}.
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
is 
\begin_inset Formula 
\begin{equation}
\widehat{u}_{i}=(x1_{i}\times x2_{i})-\widehat{(x1_{i}\times x2_{i})},
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
which is inserted into equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:int"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
y_{i}=h_{0}+h_{1}x1_{i}+h_{2}x2_{i}+h_{3}\{x1_{i}\times x2_{i}-\widehat{x1_{i}\times x2_{i}}\}+e3_{i}\label{eq:rc1}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Replacing 
\begin_inset Formula $\widehat{x1_{i}\times x2_{i}}$
\end_inset

 with 
\begin_inset Formula $\hat{d}_{0}+\hat{d}_{1}x1_{i}+\hat{d}_{2}x2_{i}$
\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rc1"

\end_inset

 becomes
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
y_{i} & = & h_{0}+h_{1}x1_{i}+h_{2}x2_{i}+h_{3}\{x1_{i}\times x2_{i}-\hat{d}_{0}-\hat{d}_{1}x1_{i}-\hat{d}_{2}x2_{i}\}+e3_{i}\\
 & = & h_{0}+h_{1}x1_{i}+h_{2}x2_{i}+h_{3}\{x1_{i}\times x2_{i}\}-h_{3}\hat{d}_{0}-h_{3}\hat{d}_{1}x1_{i}-h_{3}\hat{d}_{2}x2_{i}\}+e3_{i}\\
 &  & \{h_{0}-h_{3}\hat{d}_{0}\}+\{h_{1}-h_{3}\hat{d}_{1}\}x1_{i}+\{h_{2}-h_{3}\hat{d}_{2}\}x2_{i}+h_{3}\{x1_{i}\times x2_{i}\}+e3_{i}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
As in the previous comparison, we can translate coefficient estimates between
 the ordinary specification and the residual-centered model.
 The coefficient estimated for the product term, 
\begin_inset Formula $\hat{h}_{3}$
\end_inset

, should be equal to 
\begin_inset Formula $\hat{b}_{3}$
\end_inset

 and 
\begin_inset Formula $\hat{c}_{3}$
\end_inset

 (and it is!).
 If we fit the residual centered model, 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rc1"

\end_inset

, we can re-generate the coefficients of the other models like so: 
\begin_inset Formula 
\begin{eqnarray}
\hat{b}_{0} & =\hat{c}_{0}-\hat{c}_{1}\overline{x1}-\hat{c}_{2}\overline{x2}+\hat{c}_{3}\overline{x1}\overline{x2}= & h_{0}-h_{3}\hat{d}_{0}\\
\hat{b}_{1} & =\hat{c}_{1}-\hat{c}_{3}\overline{x2}= & h_{1}-h_{3}\hat{d}_{1}\\
\hat{b}_{2} & =\hat{c}_{2}-\hat{c}_{3}\overline{x1}= & h_{2}-h_{3}\hat{d}_{2}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
From the preceding, it should be clear enough that the three models are
 equivalent.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
The rockchalk package is offered as a system of support for teachers and
 students of regression analysis.
 It should help with the preparation of plots, summary tables, and other
 diagnostics.
 
\end_layout

\begin_layout Standard
A number of functions are currently offered in this package that have not
 been emphasized in this writeup.
 I would draw the reader to the help pages for these functions
\end_layout

\begin_layout Description
combineLevels a recoder for factor variables
\end_layout

\begin_layout Description
mcDiagnose a one stop shop for multicollinearity diagnostic information
\end_layout

\begin_layout Description
getDeltaRsquare calculate the change in the 
\begin_inset Formula $R^{2}$
\end_inset

 that results from the omission of each variable.
 This is the squared semi-partial correlation coefficient.
\end_layout

\begin_layout Description
getPartialCor calculates the partial correlation matrix of the predictors
 in a regression model
\end_layout

\begin_layout Description
lazyCor
\begin_inset space ~
\end_inset

and
\begin_inset space ~
\end_inset

lazyCov convenient ways to create correlation and covariance matrices that
 are needed in many simulation exercises
\end_layout

\begin_layout Description
mvrnorm a slightly improved version of the MASS package's multivariate normal
 generator.
\end_layout

\begin_layout Standard
Development on the package will continue on the basis of classroom experience.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "rockchalk"
options "chicago"

\end_inset


\end_layout

\end_body
\end_document
